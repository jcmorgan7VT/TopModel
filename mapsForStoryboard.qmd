---
title: "MapsForStoryboard1"
format: html
editor_options: 
  chunk_output_type: console
---
Not just maps for storyboard but also figures for storyboard

11/13/24
Making more finalized versions of maps for storyboard
 
```{r}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)


#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#plot(m10)
lcc <- terra::project(locs_shape,crs(m10))


#define the rectangular area that will be shown on final map
#determined for each watershed, from figures4poster script
ybounds <- c(4868850,4869650)
xbounds <- c(279350, 280450)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./fb_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
fb_crop <- "./fb_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
fb_net <- vect("./carrieZigZag/FB_network.shp")
plot(fb_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
fb_pour_coords <- data.frame("easting" = 280400,
                             "northing" = 4869120)
#convert to SpatVector object
fb_pour <- vect(fb_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
fb_pour_filename <- "./fb_dems/fb_pour.shp"
writeVector(fb_pour, fb_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
fb_crop <- "./fb_dems/1mdem_crop.tif"

fb_breached <- "./fb_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = fb_crop,
  output = fb_breached,
  dist = 1,
  fill = TRUE)

fb_filled <- "./fb_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = fb_breached,
  output = fb_filled
)
#calculate flow accumulation and direction
fb_flowacc <- "./fb_dems/1mdem_fb_flowacc.tif"
wbt_d8_flow_accumulation(input = fb_filled,
                         output = fb_flowacc)
plot(rast(fb_flowacc))
fb_d8pt <- "./fb_dems/1mdem_fb_d8pt.tif"
wbt_d8_pointer(dem = fb_filled,
               output = fb_d8pt)
plot(rast(fb_d8pt))


#delineate streams
fb_streams <- "./fb_dems/fb_streams.tif"
wbt_extract_streams(flow_accum = fb_flowacc,
                    output = fb_streams,
                    threshold = 8000)
plot(rast(fb_streams))
plot(as.lines((as.polygons(rast(fb_streams)))),
     xlim = c(279800, 279900), ylim = c(4869100,4869200))
#results in weird lines, figure out how to simplify
topo_streams <- as.lines(as.polygons(rast(fb_streams)))

points(lcc)
#snap pour point to streams
fb_pour_snap <- "./fb_dems/fb_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = fb_pour_filename,
                            streams = fb_streams,
                            output = fb_pour_snap,
                            snap_dist = 10)
fb_pour_snap_read <- vect("./fb_dems/fb_pour_snap.shp")
plot(rast(fb_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(fb_pour_snap_read, pch = 1)

fb_shed <- "./fb_dems/fb_shed.tif"
wbt_watershed(d8_pntr = fb_d8pt,
              pour_pts = fb_pour_snap,
              output = fb_shed)

plot(rast(fb_shed))
#convert raster of watershed area to vector for final mapping
fb_outline <- as.polygons(rast(fb_shed), extent=FALSE)
plot(fb_outline)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)

#assign destination for hillshade calculation
hillshade_out <- "./fb_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = fb_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)

fb_slope <- "./fb_dems/1mdem_slope.tif"
wbt_slope(dem = fb_filled,
          output = fb_slope,
          units = "degrees")

fb_twi <- "./fb_dems/1mdem_twi.tif"
wbt_wetness_index(sca = fb_flowacc, #flow accumulation
                  slope = fb_slope,
                  output = fb_twi)


#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
fb_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = fb_outline, fill = NA, color = "black", alpha = 0.3) +#, lwd = 3) +
  geom_sf(data = fb_net, colour = "darkslategray3") +#, lwd = 3) +
    geom_sf(data = lcc, colour = "midnightblue") + #, pch = 19, size = 6) +
  geom_sf(data = fb_pour, colour = "black") + #, pch = 8, size = 3) +
   scale_fill_hypso_c(palette = "dem_screen", limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))+
  ggspatial::annotation_scale(location = 'tr', pad_x = unit(0.5, "cm"), 
                              pad_y = unit(0.5, "cm")) #, line_width = 3, text_cex = 5, tick_height = 20)

fb_map

#in addition, make map of TWI, and 
twi_output <- "./fb_dems/10mdem_twi.tif"

plot(rast(twi_output), xlim = xbounds, ylim = ybounds)
ggplot()+
  geom_spatraster(data = rast(twi_output))+
  theme_void()+
  lims(x = xbounds, y = ybounds)+
  theme(legend.position = "")+
  #scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    #new_scale_fill() +
  #geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = fb_outline, fill = NA, color = "black", alpha = 0.3) +#, lwd = 3) +
  #geom_sf(data = fb_net, colour = "darkslategray3") +#, lwd = 3) +
    geom_sf(data = lcc, colour = "midnightblue", pch = 1) + #, pch = 19, size = 6) +
 # geom_sf(data = fb_pour, colour = "black") + #, pch = 8, size = 3) +
   scale_fill_hypso_c(palette = "arctic")+
  theme(rect = element_rect(fill = "transparent", color = NA))+
  ggspatial::annotation_scale(location = 'tr', pad_x = unit(0.5, "cm"), 
                              pad_y = unit(0.5, "cm"))

#read in NAIP imagery for true color composite image
color <- sprc(c("./HB/Original zips/m_4307102_ne_19_030_20230823.jp2",
       "./HB/Original zips/m_4307102_nw_19_030_20230823.jp2",
       "./HB/Original zips/m_4307102_se_19_030_20230823.jp2",
       "./HB/Original zips/m_4307102_sw_19_030_20230823.jp2",
       "./HB/Original zips/m_4307103_ne_19_030_20230823.jp2",
       "./HB/Original zips/m_4307103_nw_19_030_20230823.jp2"))

stackT <- stack("./HB/Original zips/m_4307103_nw_19_030_20230823.jp2")


plot(rast("./HB/Original zips/m_4307103_nw_19_030_20230823.jp2"))
naip_csf_br <- brick(naip_csf_st)
inMemory(naip_csf_br)

plotRGB(naip_csf_br,
        r = 1, g = 2, b = 3,
        main = "RGB image \nColdsprings fire scar")
big_image <- merge(color)
```
 

#Distribution of topographic variables
##FB
```{r}
#get the areas of each watershed, and the whole valley
#delineate shed and stream using 10m dem
#floacc calculated in previous script
flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
plot(rast(flowacc_output))
#delineate streams
#delineating whole valley, 10 m resolution
fb_streams <- "./fb_dems/10m_fb_streams.tif"
wbt_extract_streams(flow_accum = flowacc_output,
                    output = fb_streams,
                    threshold = 8000)
plot(rast(fb_streams))
#snap pour point to streams
fb_pour_snap <- "./fb_dems/10m_fb_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = fb_pour_filename,
                            streams = fb_streams,
                            output = fb_pour_snap,
                            snap_dist = 20)
fb_pour_snap_read <- vect(fb_pour_snap)
plot(rast(fb_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(fb_pour_snap_read, pch = 1)

# 1 meter dem based outline
fb_shed <- "./fb_dems/fb_shed.tif"
wbt_watershed(d8_pntr = fb_d8pt,
              pour_pts = fb_pour_snap,
              output = fb_shed)

plot(rast(fb_shed))
#convert raster of watershed area to vector for final mapping
fb_outline <- as.polygons(rast(fb_shed), extent=FALSE)
plot(fb_outline)
#get rasters of the whole valley

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
twi_output <- "./fb_dems/10mdem_twi.tif"
#crop rasters of different topographic variables


#create plots of distribution
```
##ZZ
##W3

12/30/24
QPM analysis for Kevin

Get one scenario to work, then apply to different wetness conditions. If I have time, create a shiny app to explore how changing different parameters impacts contribution to the stream at different wetness levels.
```{r}
#start with hydro enforced DEM
one <- rast("./HB/1m hydro enforced DEM/hydem1mlpns.tif")
#delineate watershed

####delineate watershed and keep watershed boundary
ybounds <- c(4870350,4871350)
xbounds <- c(281350, 282150)
plot(one, xlim = xbounds, ylim = ybounds)
#create a SpatExtent from a vector 
crop1 <- crop(one, ext(c(xbounds, ybounds)))
#save cropped 1m dem to reduce processing time below, and guarantee that everything has the same extent
writeRaster(crop1, "./w3_dems/hydem1mlpns_crop.tif", overwrite = TRUE)
#read in cropped dem
w3_crop <- "./w3_dems/hydem1mlpns_crop.tif"
#calculate flow accumulation and direction
w3_flowacc <- "./w3_dems/hydem1mlpns_flowacc.tif"
wbt_d8_flow_accumulation(input = w3_crop,
                         output = w3_flowacc)
plot(rast(w3_flowacc))
w3_d8pt <- "./w3_dems/hydem1mlpns_d8pt.tif"
wbt_d8_pointer(dem = w3_crop,
               output = w3_d8pt)
plot(rast(w3_d8pt))


#delineate streams
w3_streams_ext <- "./w3_dems/hydem1mlpns_streams_ext.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ext,
                    threshold = 8000)
plot(rast(w3_streams_ext))

w3_streams_ret <- "./w3_dems/hydem1mlpns_streams_ret.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ret,
                    threshold = 33000)
plot(rast(w3_streams_ret))

w3_pour_filename <- "./w3_dems/w3_pour.shp"
w3_pour_snap <- "./w3_dems/w3_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = w3_pour_filename,
                            streams = w3_streams_ext,
                            output = w3_pour_snap,
                            snap_dist = 10)
w3_pour_snap_read <- vect("./w3_dems/w3_pour_snap.shp")
plot(rast(w3_streams_ext), 
     xlim = c(281400, 281800),
     ylim = c(4870400, 4870600))
points(w3_pour_snap_read, pch = 1)

w3_shed <- "./w3_dems/hydem1mlpns_shed.tif"
wbt_watershed(d8_pntr = w3_d8pt,
              pour_pts = w3_pour_snap,
              output = w3_shed)
plot(rast(w3_shed))
#crop and mask to W3
w3_only <- crop1 %>% 
  mask(rast(w3_shed))
plot(w3_only)
#save output as a new DEM
writeRaster(w3_only, "./w3_dems/hydem1mlpns_wsbound.tif", overwrite = TRUE)

#use new DEM to calculate downslope distance to stream
#or how far the water has to go
bound_dem <- "./w3_dems/hydem1mlpns_wsbound.tif"
w3_downdist_ext <- "./w3_dems/hydem1mlpns_downdist_ext.tif"
wbt_downslope_distance_to_stream(dem = bound_dem,
                                 streams = w3_streams_ext,
                                 output = w3_downdist_ext)
plot(rast(w3_downdist_ext))
#then calculate how far the water can go, based on slope and calculation
##calculate average flowpath slope
w3_avgflowslope_ext <- "./w3_dems/hydem1mlpns_avgflowslope_ext.tif"
#output already in degrees
wbt_average_flowpath_slope(dem = bound_dem,
                           output = w3_avgflowslope_ext)
plot(rast(w3_avgflowslope_ext))
##calculate Lt based on slope and input values
#input parameters
Ku_Kl <- 10
N <- 0.35 #meters
Cn <- 2.8
rads <- rast(w3_avgflowslope_ext) * pi/180
#caluclate Lt, or travel distance of lateral water flux
Lt <- Ku_Kl * (sin(rads)/((N + Cn)/Cn)) * N
plot(Lt)
#still getting negative numbers? converted to radians, r funciton is looking for rads

#visualize results with a map, showing the contributing area
#find areas where the Lt is greater than or equal to the downdist
plot(rast(w3_downdist_ext))
o <- rast(w3_downdist_ext)
plot(Lt$hydem1mlpns_avgflowslope_ext[Lt$hydem1mlpns_avgflowslope_ext>=o$hydem1mlpns_downdist_ext])

(Lt$hydem1mlpns_avgflowslope_ext[Lt$hydem1mlpns_avgflowslope_ext== 1])
plot(o)
plot(Lt)

x <- ifel(o <= Lt, 1, 0)
plot(x)

#result is really weird, and I am having trouble sub-setting one raster based on the other
```

Try again with a coarser raster
```{r}
aggreg_factor <- 10
#start with hydro enforced DEM
one <- rast("./HB/1m hydro enforced DEM/hydem1mlpns.tif")
#delineate watershed

####delineate watershed and keep watershed boundary
ybounds <- c(4870350,4871350)
xbounds <- c(281350, 282150)
plot(one, xlim = xbounds, ylim = ybounds)
#create a SpatExtent from a vector 
m10 <- aggregate(m1, aggreg_factor)

crop1 <- crop(m10, ext(c(xbounds, ybounds)))
#save cropped 1m dem to reduce processing time below, and guarantee that everything has the same extent
writeRaster(crop1, "./w3_dems/hydem1mlpns_crop.tif", overwrite = TRUE)
#read in cropped dem
w3_crop <- "./w3_dems/hydem1mlpns_crop.tif"
#calculate flow accumulation and direction
w3_flowacc <- "./w3_dems/hydem1mlpns_flowacc.tif"
wbt_d8_flow_accumulation(input = w3_crop,
                         output = w3_flowacc)
plot(rast(w3_flowacc))
w3_d8pt <- "./w3_dems/hydem1mlpns_d8pt.tif"
wbt_d8_pointer(dem = w3_crop,
               output = w3_d8pt)
plot(rast(w3_d8pt))


#delineate streams
w3_streams_ext <- "./w3_dems/hydem10mlpns_streams_ext.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ext,
                    threshold = 300)
plot(rast(w3_streams_ext))

w3_streams_ret <- "./w3_dems/hydem10mlpns_streams_ret.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ret,
                    threshold = 300)
plot(rast(w3_streams_ret))

w3_pour_filename <- "./w3_dems/w3_pour.shp"
w3_pour_snap <- "./w3_dems/w3_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = w3_pour_filename,
                            streams = w3_streams_ext,
                            output = w3_pour_snap,
                            snap_dist = 10)
w3_pour_snap_read <- vect("./w3_dems/w3_pour_snap.shp")
plot(rast(w3_streams_ext), 
     xlim = c(281400, 281800),
     ylim = c(4870400, 4870600))
points(w3_pour_snap_read, pch = 1)

w3_shed <- "./w3_dems/hydem1mlpns_shed.tif"
wbt_watershed(d8_pntr = w3_d8pt,
              pour_pts = w3_pour_snap,
              output = w3_shed)
plot(rast(w3_shed))
#crop and mask to W3
w3_only <- crop1 %>% 
  mask(rast(w3_shed))
plot(w3_only)
#save output as a new DEM
writeRaster(w3_only, "./w3_dems/hydem1mlpns_wsbound.tif", overwrite = TRUE)

#use new DEM to calculate downslope distance to stream
#or how far the water has to go
bound_dem <- "./w3_dems/hydem1mlpns_wsbound.tif"
w3_downdist_ext <- "./w3_dems/hydem1mlpns_downdist_ext.tif"
wbt_downslope_distance_to_stream(dem = bound_dem,
                                 streams = w3_streams_ext,
                                 output = w3_downdist_ext)
plot(rast(w3_downdist_ext))
#then calculate how far the water can go, based on slope and calculation
##calculate average flowpath slope
w3_avgflowslope_ext <- "./w3_dems/hydem1mlpns_avgflowslope_ext.tif"
#output already in degrees
wbt_average_flowpath_slope(dem = bound_dem,
                           output = w3_avgflowslope_ext)
plot(rast(w3_avgflowslope_ext))
##calculate Lt based on slope and input values
#input parameters
Ku_Kl <- 600
N <- 0.35 #meters
Cn <- 2.8
rads <- rast(w3_avgflowslope_ext) * pi/180
#caluclate Lt, or travel distance of lateral water flux
Lt <- Ku_Kl * (sin(rads)/((N + Cn)/Cn)) * N #* aggreg_factor
plot(Lt)
#still getting negative numbers? converted to radians, r funciton is looking for rads

#visualize results with a map, showing the contributing area
#find areas where the Lt is greater than or equal to the downdist
plot(rast(w3_downdist_ext))
o <- rast(w3_downdist_ext)
plot(Lt$hydem1mlpns_avgflowslope_ext[Lt$hydem1mlpns_avgflowslope_ext>=o$hydem1mlpns_downdist_ext])

(Lt$hydem1mlpns_avgflowslope_ext[Lt$hydem1mlpns_avgflowslope_ext== 1])
plot(o)
plot(Lt)

x <- ifel(o <= Lt, 1, NA)
plot(x)
streams <- rast(w3_streams_ext) %>% 
  mask(rast(w3_shed))
plot(streams)
activated <- ifel(x == streams, 2, x)

plot(activated)
#result is really weird, and I am having trouble sub-setting one raster based on the other
```

```{r}
#final plot of contributing area
w3_outline <- as.polygons(rast(w3_shed), extent=FALSE)
writeVector(w3_outline, "./w3_dems/10m_shedbound.shp")
plot(w3_outline)
hillshade_out <- "./w3_dems/1mdem_hillshade.tif"
hill <- rast(hillshade_out)

cls <- c("activated hillslope", "stream")
df <- data.frame(id = 1:2, class=cls)
levels(activated) <- df
activated <- mask(activated, x)
w3_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("gray9", "gray48","lightgray", "white"), guide = 'none')+
    new_scale_fill() +
  geom_spatraster(data = drop_na(activated), aes(fill = class), alpha = 0.7)+
  scale_fill_manual(values = c("lightblue", "purple"),
                    na.translate=FALSE)+
               theme_void()+
  geom_sf(data = w3_outline, fill = NA, color = "black", alpha = 0.3, lwd = 1)+
  theme(rect = element_rect(fill = "transparent", color = NA),
        legend.title=element_blank())

w3_map

#visualization that uses df versions of raster files
hillshade2 <- as.data.frame(rast(activated), xy = TRUE) %>% drop_na()


ggplot()+
  geom_raster(data = hillshade2,
              aes(x = x, y = y, fill = as.numeric('1mdem_hillshade'))) + 
  #scale_alpha(range =  c(0.15, 0.65), guide = "none") + 
  coord_quickmap()
```

```{r}
#create a stream network raster with the drainage area of each pixel as the value.
w3_streams_ext <- "./w3_dems/hydem10mlpns_streams_ext.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ext,
                    threshold = 80)
plot(rast(w3_streams_ext))

w3_streams_ret <- "./w3_dems/hydem10mlpns_streams_ret.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams_ret,
                    threshold = 300)
plot(rast(w3_streams_ret))

#crop to watershed area
streams <- rast(w3_streams_ext) %>% 
  mask(rast(w3_shed))
plot(streams)

#get values of raster to be drainage area
w3_flowacc <- "./w3_dems/hydem1mlpns_flowacc.tif"
wbt_d8_flow_accumulation(input = w3_crop,
                         output = w3_flowacc)
plot(rast(w3_flowacc))

drain <- mask(rast(w3_flowacc), streams)
plot(drain)

writeRaster(drain, "./w3_dems/hydem10mlpns_uaa_streams.tif", overwrite = TRUE)

make_files <- function(uaa){
  bound_dem <- "./w3_dems/hydem1mlpns_wsbound.tif"
  downdist_calc <- paste0("app exports/",uaa,"_downdist.tif")
  streams_path <- paste0("app exports/",uaa,"_stream.tif")
  
  streams <- ifel(drain >= uaa, 1, NA)
  writeRaster(streams, streams_path, 
              overwrite = TRUE)
  wbt_downslope_distance_to_stream(dem = bound_dem,
                                   streams = streams_path,
                                    output = downdist_calc)

  flowslope_calc <- paste0("app exports/",uaa,"_flowslope.tif")
#output already in degrees
  wbt_average_flowpath_slope(dem = bound_dem,
                             output = flowslope_calc)

}
make_files(80)
make_files(200)
make_files(300)

plot(rast(paste0("app exports/",200,"_stream.tif")))
plot(o)
plot(ifel(drain >= 80, 1, NA)) #units are 10 m^2, so this is 400,000 m
plot(ifel(drain >= 200, 1, NA))
plot(ifel(drain >= 300, 1, NA))

plot(rast(paste0("app exports/",80,"_downdist.tif")))
plot(rast(paste0("app exports/",200,"_downdist.tif")))
plot(rast(paste0("app exports/",300,"_downdist.tif")))

#save to app exports folder
writeRaster(x, "app exports/80_avgflowslope.tif")
writeRaster(x, "app exports/120_avgflowslope.tif")
writeRaster(x, "app exports/300_avgflowslope.tif")

activated2 <- ifel(x == drain2, 2, x)
plot(activated2)
plot(x)
area(x$hydem1mlpns_downdist_ext)
terra::zonal(x,x, sum, na.rm=TRUE)

f <- freq(x)
f$area <- f$count

hillshade_out <- "./w3_dems/1mdem_hillshade.tif"
hill <- rast(hillshade_out)
hcl.colors(20, palette = "Grays")
plot(hill, col = hcl.colors(20, palette = "Grays"))

#get soil model ready for app
plot(rast("HB/HBsoils.tif"))
plot(crop(rast("HB/HBsoils.tif"), ext(c(xbounds, ybounds))))
writeRaster(crop(rast("HB/HBsoils.tif"), ext(c(xbounds, ybounds))), "soilCrop.tif")

```

```{r FAILED-vectorize-and-precalc}
#to avoid whitebox tools, go ahead and figure out all possible drainage distance values for my dataset

plot(drain)
hist(drain)

output <- as.data.frame(drain, xy = TRUE) %>% drop_na() %>% 
  rename("iterating" = hydem1mlpns_flowacc)
output$threshold <- 0
#now just loop through this list with my threshold and distance traveled, then I can rasterize it
ls <- seq(80, 300, 1)
for(i in 1:length(ls)){
  uaa2 <- ifel(drain >= ls[i], 1, NA)
  writeRaster(uaa2, "uaa_thresholded.tif", overwrite = TRUE)
  wbt_downslope_distance_to_stream(dem = bound_dem,
                                     streams = "uaa_thresholded.tif",
                                     output = "iterating.tif")
  it <- rast("iterating.tif")
  it_df <- as.data.frame(it, xy = TRUE) %>% drop_na() %>% 
    mutate(threshold = ls[i])
  output <- rbind(output, it_df)
}
 as_tibble(output)
#then group by x and y, summarise to find the min threshold I think
formatted <- as_tibble(output) %>% 
  group_by(x, y) %>% 
  summarise(min = min(threshold)) 

hist(formatted$min)
  
plot(rast("iterating.tif"))
it <- rast("iterating.tif")
  it_df <- as.data.frame(it, xy = TRUE) %>% drop_na() %>% 
    mutate(threshold = 2)
#will be filtered from 80-300

```










