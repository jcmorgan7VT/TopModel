---
title: "Test Frameworks"
format: html
editor: visual
---

9/8/24
Test different theoretical frameworks using my data.
```{r reading-in-STIC-obs}
library(pacman)
p_load(tidyverse, terra)
#reading in final format data for summer 23
data_23 <- read_csv("./DataForMary/HB_stic.csv")
#reading in final format data for summer 24
data_24 <- read_csv("./summer2024/STICS2024.csv")
```
9/10/24
Make figures showing the full period of record
```{r}
binary <- c("#DB995A",
            "#586BA4"
  )

data_23$mins <- minute(data_23$datetime)
data_24$mins <- minute(data_24$datetime)

head(filter(data_23, wshed == "W3", deployment == 1))
ggplot()+
  geom_tile(data = filter(data_23, wshed == "W3", mins %in% c(0, 30)),
            aes(x = datetime, y = ID, fill = wetdry))+
  geom_tile(data = filter(data_24, wshed == "W3", mins %in% c(0, 30)),
            aes(x = datetime, y = number, fill = wetdry))+
  #facet_grid(~deployment, scales = "free") + 
  scale_fill_manual(drop = FALSE,
                     values = binary,
                    breaks = c("dry", "wet"),
                    labels = c("No flow", "flowing"),
                    name = ""
                    )+
  labs(title = "Streamflow permanence in W3",
       x = "")+
  theme_classic()
```

FB
```{r}

head(filter(data_24, wshed == "FB", sensor == 21736589))

ggplot()+
  geom_tile(data = filter(data_23, wshed == "FB", mins %in% c(0, 30)),
            aes(x = datetime, y = ID, fill = wetdry))+
  geom_tile(data = filter(data_24, wshed == "FB", mins %in% c(0, 30)),
            aes(x = datetime, y = number, fill = wetdry))+
  #facet_grid(~deployment, scales = "free") + 
  scale_fill_manual(drop = FALSE,
                     values = binary,
                    breaks = c("dry", "wet"),
                    labels = c("No flow", "flowing"),
                    name = ""
                    )+
  labs(title = "Streamflow permanence in FB",
       x = "")+
  theme_classic()
```
ZZ
```{r}
ggplot()+
  geom_tile(data = filter(data_23, wshed == "ZZ", mins %in% c(0, 30)),
            aes(x = datetime, y = ID, fill = wetdry))+
  geom_tile(data = filter(data_24, wshed == "ZZ", mins %in% c(0, 30)),
            aes(x = datetime, y = number, fill = wetdry))+
  #facet_grid(~deployment, scales = "free") + 
  scale_fill_manual(drop = FALSE,
                     values = binary,
                    breaks = c("dry", "wet"),
                    labels = c("No flow", "flowing"),
                    name = ""
                    )+
  labs(title = "Streamflow permanence in ZZ",
       x = "")+
  theme_classic()
```

Start with Carrie's model- how well does it capture the dynamics that I observed?
```{r}
#read in discharge from W3-- input to Carrie's model, discharge in L/s
q <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-hbr.1.17&entityid=efc477b3ef1bb3dd8b9355c9115cd849")
#input discharge needs to be in mm/day?
#reference to understand difference between daily mean and instantaneous streamflow:
#https://hydrofunctions.readthedocs.io/en/master/notebooks/DailyMean_vs_Instant.html

#creating minute column, used to filter out higher temporal resolution measurements for plotting
data_23$mins <- minute(data_23$datetime)
data_24$mins <- minute(data_24$datetime)

#find the range of dates that I need discharge for
start <- min(data_23$datetime)
stop <- max(data_23$datetime)

#filtering discharge down to the range of dates
q_23 <- q %>% 
  filter(DATETIME > start & DATETIME < stop) %>% 
  #convert to mm/day.
  #converting instantaneous streamflow to mm/day by taking measurement, and scaling   it up as if that was the discharge for the whole day. It is not, it is just at that   moment, but should fix any units/order of magnitude issues
  mutate("Q_mm_day" = Discharge_ls * 0.001 * 86400 / 420000 * 1000) 
q_23$mins <- minute(q_23$DATETIME)

#removing times that are not coincident with STIC observations
q_23_f <- filter(q_23, mins %in% c(0, 30))

ggplot(q_23_f, aes(x  = DATETIME, y = Q_mm_day))+
  geom_line()+
  labs(title = "Discharge from W3, July to Nov 2023",
       x = "",
       y = "Instantaneous Q (mm/day)")+
  theme_classic()

```
  
```{r}
#calculate then extract the TWI at each of the sensor locations. May be tricky to make sure that they line up with flowlines, or places with greatest drainage area.
twi3 <- "./w3_dems/w3_dem_twi.tif"
#twi calculated in script topmodel_fromscratch_2_23_23.Rmd
twi3 <- rast(twi3)
plot(twi3)

#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "W3") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
lcc <- terra::project(locs_shape,crs(twi3))

#extract twi values using terra::extract
twi_ex <- extract(twi3, lcc)

#these point locations are not manually corrected.
#in next chunk, calculate the percent chance that each spot is flowing based off of an input discharge
```

```{r}
#chunk that is actually running the model

#function to calculate probability of flow raster
willit <- function(input_logtwi, inputQ){
  #b0, or intercept from Kevin's email from Carrie, might need to redo regression
  b0 <- -35.43
  #all ofther coefs from Jensen et al. 2018
  twi_coef <- 15.57
  flow_coef <- 0.12

  b1x1 <- flow_coef * inputQ
  b2x2 <- twi_coef * input_logtwi

  #logistic regression from Jensen et al. 2018
  p <- exp(b0 + b1x1 + b2x2)/(1 + exp(b0 + b1x1 + b2x2))
  return(p)
}

test <- willit(log(twi3), 1)
plot(test)
#after running, threshold by some probability of flowing
#loop through the input dataframe of discharge, once for each sensor. make an indexed array perhaps?

test <- willit(twi_ex$w3_dem_twi, q_23_f$Q_mm_day)

#for tomorrow- get this to work. Will need to run it throughout the entire discharge record?
for(i in 1:length(twi_ex$ID)){
  out <- willit(log(twi_ex$w3_dem_twi), runs[i])
  out2 <- out %>%
  rasterToPoints %>%
  as.data.frame()
  
  out2$DATE <- dates[i]
  
  if(i == 1) final <- out2
  if(i > 1) final <- rbind(final, out2)

}
```

