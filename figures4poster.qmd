---
title: "Figures4Poster"
format: html
editor_options: 
  chunk_output_type: console
---
Water center colloquium poster figures 2024
```{r reading-in-STIC-obs}
#loading packages
library(pacman)
p_load(tidyverse, terra, tidyterra, whitebox, scales, wesanderson, caret, plotly,
       ggnewscale, sf, rgeoboundaries, elevatr, patchwork, ggspatial)

#reading in final format data for summer 23
data_23 <- read_csv("./DataForMary/HB_stic.csv")
#reading in final format data for summer 24
data_24 <- read_csv("./summer2024/STICS2024.csv")
```

#Making maps for poster

```{r fallsBrook-map}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#define the rectangular area that will be shown on final map
ybounds <- c(4868850,4869650)
xbounds <- c(279350, 280450)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./fb_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
fb_crop <- "./fb_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
fb_net <- vect("./carrieZigZag/FB_network.shp")
plot(fb_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
fb_pour_coords <- data.frame("easting" = 280400,
                             "northing" = 4869120)
#convert to SpatVector object
fb_pour <- vect(fb_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
fb_pour_filename <- "./fb_dems/fb_pour.shp"
writeVector(fb_pour, fb_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
fb_crop <- "./fb_dems/1mdem_crop.tif"

fb_breached <- "./fb_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = fb_crop,
  output = fb_breached,
  dist = 1,
  fill = TRUE)

fb_filled <- "./fb_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = fb_breached,
  output = fb_filled
)
#calculate flow accumulation and direction
fb_flowacc <- "./fb_dems/1mdem_fb_flowacc.tif"
wbt_d8_flow_accumulation(input = fb_filled,
                         output = fb_flowacc)
plot(rast(fb_flowacc))
fb_d8pt <- "./fb_dems/1mdem_fb_d8pt.tif"
wbt_d8_pointer(dem = fb_filled,
               output = fb_d8pt)
plot(rast(fb_d8pt))


#delineate streams
fb_streams <- "./fb_dems/fb_streams.tif"
wbt_extract_streams(flow_accum = fb_flowacc,
                    output = fb_streams,
                    threshold = 8000)
plot(rast(fb_streams))
points(lcc)
#snap pour point to streams
fb_pour_snap <- "./fb_dems/fb_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = fb_pour_filename,
                            streams = fb_streams,
                            output = fb_pour_snap,
                            snap_dist = 10)
fb_pour_snap_read <- vect("./fb_dems/fb_pour_snap.shp")
plot(rast(fb_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(fb_pour_snap_read, pch = 1)

fb_shed <- "./fb_dems/fb_shed.tif"
wbt_watershed(d8_pntr = fb_d8pt,
              pour_pts = fb_pour_snap,
              output = fb_shed)

plot(rast(fb_shed))
#convert raster of watershed area to vector for final mapping
fb_outline <- as.polygons(rast(fb_shed), extent=FALSE)
plot(fb_outline)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)

#assign destination for hillshade calculation
hillshade_out <- "./fb_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = fb_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)

#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
fb_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = fb_outline, fill = NA, color = "black", alpha = 0.3, lwd = 3) +
  geom_sf(data = fb_net, colour = "darkslategray3", lwd = 3) +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19, size = 6) +
  geom_sf(data = fb_pour, colour = "black", pch = 8, size = 3) +
   scale_fill_hypso_c(palette = "dem_screen", limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))+
  ggspatial::annotation_scale(location = 'tr', pad_x = unit(4, "cm"), 
                              pad_y = unit(4, "cm"),
                              line_width = 3, text_cex = 5, tick_height = 20)

fb_map
```
```{r zigZag-map}
#map for ZZ
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "ZZ") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)
#define the rectangular area that will be shown on final map
ybounds <- c(4866400,4867500)
xbounds <- c(277200, 277650)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./zz_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
zz_crop <- "./zz_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
zz_net <- vect("./carrieZigZag/zigzag_streams.shp")
plot(zz_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
 4867436.45

zz_pour_coords <- data.frame("easting" = 277280.45,
                             "northing" = 4867436.45)
#convert to SpatVector object
zz_pour <- vect(zz_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
zz_pour_filename <- "./zz_dems/zz_pour.shp"
writeVector(zz_pour, zz_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
zz_crop <- "./zz_dems/1mdem_crop.tif"

zz_breached <- "./zz_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = zz_crop,
  output = zz_breached,
  dist = 1,
  fill = TRUE)

zz_filled <- "./zz_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = zz_breached,
  output = zz_filled
)
#calculate flow accumulation and direction
zz_flowacc <- "./zz_dems/1mdem_zz_flowacc.tif"
wbt_d8_flow_accumulation(input = zz_filled,
                         output = zz_flowacc)
plot(rast(zz_flowacc))
zz_d8pt <- "./zz_dems/1mdem_zz_d8pt.tif"
wbt_d8_pointer(dem = zz_filled,
               output = zz_d8pt)
plot(rast(zz_d8pt))


#delineate streams
zz_streams <- "./zz_dems/zz_streams.tif"
wbt_extract_streams(flow_accum = zz_flowacc,
                    output = zz_streams,
                    threshold = 8000)
plot(rast(zz_streams))
points(lcc)
#snap pour point to streams
zz_pour_snap <- "./zz_dems/zz_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = zz_pour_filename,
                            streams = zz_streams,
                            output = zz_pour_snap,
                            snap_dist = 10)
zz_pour_snap_read <- vect("./zz_dems/zz_pour_snap.shp")
plot(rast(zz_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(zz_pour_snap_read, pch = 1)

zz_shed <- "./zz_dems/zz_shed.tif"
wbt_watershed(d8_pntr = zz_d8pt,
              pour_pts = zz_pour_snap,
              output = zz_shed)

plot(rast(zz_shed))
#convert raster of watershed area to vector for final mapping
zz_outline <- as.polygons(rast(zz_shed), extent=FALSE)
plot(zz_outline)



#assign destination for hillshade calculation
hillshade_out <- "./zz_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = zz_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)
#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
zz_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = zz_outline, fill = NA, color = "black", alpha = 0.3, lwd = 3) +
  geom_sf(data = zz_net, colour = "darkslategray3", lwd = 3) +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19, size = 6) +
  geom_sf(data = zz_pour, colour = "black", pch = 8, size = 3) +
   scale_fill_hypso_c(palette = "dem_screen", limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))+
  ggspatial::annotation_scale(location = 'tr', pad_x = unit(4, "cm"), 
                              pad_y = unit(4, "cm"),
                              line_width = 3, text_cex = 5, tick_height = 20)

zz_map
```
```{r w3-map}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "W3") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)
#define the rectangular area that will be shown on final map
ybounds <- c(4870350,4871350)
xbounds <- c(281350, 282150)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./w3_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
w3_crop <- "./w3_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
w3_net <- vect("./carrieZigZag/w3_network.shp")
plot(w3_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
 
 
w3_pour_coords <- data.frame("easting" = 281537.46,
                             "northing" = 4870424.50)
#convert to SpatVector object
w3_pour <- vect(w3_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
w3_pour_filename <- "./w3_dems/w3_pour.shp"
writeVector(w3_pour, w3_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
w3_crop <- "./w3_dems/1mdem_crop.tif"

w3_breached <- "./w3_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = w3_crop,
  output = w3_breached,
  dist = 1,
  fill = TRUE)

w3_filled <- "./w3_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = w3_breached,
  output = w3_filled
)
#calculate flow accumulation and direction
w3_flowacc <- "./w3_dems/1mdem_w3_flowacc.tif"
wbt_d8_flow_accumulation(input = w3_filled,
                         output = w3_flowacc)
plot(rast(w3_flowacc))
w3_d8pt <- "./w3_dems/1mdem_w3_d8pt.tif"
wbt_d8_pointer(dem = w3_filled,
               output = w3_d8pt)
plot(rast(w3_d8pt))


#delineate streams
w3_streams <- "./w3_dems/w3_streams.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams,
                    threshold = 8000)
plot(rast(w3_streams))
points(lcc)
#snap pour point to streams
w3_pour_snap <- "./w3_dems/w3_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = w3_pour_filename,
                            streams = w3_streams,
                            output = w3_pour_snap,
                            snap_dist = 10)
w3_pour_snap_read <- vect("./w3_dems/w3_pour_snap.shp")
plot(rast(w3_streams), 
     xlim = c(281400, 282000),
     ylim = c(4870400, 4870800))
points(w3_pour_snap_read, pch = 1)

w3_shed <- "./w3_dems/w3_shed.tif"
wbt_watershed(d8_pntr = w3_d8pt,
              pour_pts = w3_pour_snap,
              output = w3_shed)

plot(rast(w3_shed))
#convert raster of watershed area to vector for final mapping
w3_outline <- as.polygons(rast(w3_shed), extent=FALSE)
plot(w3_outline)



#assign destination for hillshade calculation
hillshade_out <- "./w3_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = w3_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)

#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
w3_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = w3_outline, fill = NA, color = "black", alpha = 0.3, lwd = 3)+
  geom_sf(data = w3_net, colour = "darkslategray3", lwd = 3) +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19, size = 6) +
  geom_sf(data = w3_pour, colour = "black", pch = 8, size = 3) +
   scale_fill_hypso_c(palette = "dem_screen" , limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))+
  ggspatial::annotation_scale(location = 'tr', pad_x = unit(4, "cm"), 
                              pad_y = unit(4, "cm"),
                              line_width = 3, text_cex = 5, tick_height = 20)

w3_map


```
```{r combine-maps}
#combine and save all maps
all_map <- w3_map + fb_map + zz_map +
  theme(rect = element_rect(fill = "transparent", color = NA))

all_map
#24 in by 16
# ggsave("all.png", plot = all_map, scale = 2, limitsize = FALSE, height = 16,
#        width = 24, units = "in", bg = NULL,)
#no matter what I do, I cannot get these formatted how I want them

ggsave("w3.png", plot = w3_map, scale = 2, limitsize = FALSE, height = 11,
       width = 9, units = "in", bg = NULL,)

ggsave("fb.png", plot = fb_map, scale = 2, limitsize = FALSE, height = 11,
       width = 9, units = "in", bg = NULL,)

ggsave("zz.png", plot = zz_map, scale = 2, limitsize = FALSE, height = 11,
       width = 9, units = "in", bg = NULL,)

```

```{r NH-map-unfinised}
#make map of NH, pane to show where hubbard brook is
usa <- rgeoboundaries::geoboundaries("USA", "adm1")
NH <- usa[usa$shapeName == "New Hampshire",]
NH_outline <- vect(NH)
mdt <- get_elev_raster(locations = NH, z = 10, clip = "locations")
plot(mdt)
big <- rast(mdt) %>% 
  crop(NH_outline) %>% 
  mask(NH_outline)
writeRaster(big, "./w3_dems/NH.tif", overwrite = TRUE)

NH_path <- "./w3_dems/NH.tif"
hillshade_out <- "./w3_dems/NH_hillshade.tif"
wbt_hillshade(
  dem = NH_path,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
hill2 <- crop(hill, NH_outline)
hill3 <- mask(hill2, NH_outline)
plot(hill)

#read in shapefil of watershed boundaries for HB
#path to file
HB_bounds <- "./HB/hbef_wsheds/hbef_wsheds.shp"
sheds <- vect(HB_bounds)
sheds <- terra::project(sheds, crs(hill))
plot(sheds)

#use bounds of sheds to crop NH dem
ybounds <- c(43.916,43.96219)
xbounds <- c(-71.80451, -71.69687)
plot(hill, xlim = xbounds, ylim = ybounds)
gauge <- c(43.939574, -71.703100)


NH_map <- ggplot()+
  geom_spatraster(data = hill3)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"), na.value = NA)+
    new_scale_fill() +
  geom_spatraster(data = big, alpha = 0.5)+
  #plot star to represent hubbard brook location
    geom_point(aes(y=43.939574, x=-71.703100), colour="black", pch = 20, size = 8)+
   scale_fill_hypso_c(palette = "dem_screen")
NH_map

ggsave("NH.png", plot = NH_map, scale = 1, limitsize = FALSE, #height = 11,width = 4, units = "in"
       bg = NULL,)

ggplot()+
  geom_spatraster(data = hill3)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"), na.value = NA)+
    new_scale_fill() +
  geom_spatraster(data = big, alpha = 0.5)+
    geom_sf(data = sheds, fill = "darkslategray3", color = "black", alpha = 0.3) +
   scale_fill_hypso_c(palette = "dem_screen")+
  lims(x = xbounds,
       y = ybounds)
```

#Making tables for poster  
##topography. 
###Falls Brook
```{r fb-topography-prep}
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
#plot(twi2)

#just extract values from 10 m twi raster
FB_twi_ex <- extract(twi2, lcc)

```

```{r functions}
#originallly written for twi logistic regression, but easily transferable to any other fitted logistic regression models
john_reg <- function(input_logtwi, inputQ){
  #b0, or intercept from Kevin's email from Carrie, might need to redo regression
  b0 <- unname(model$coefficients[1])
  #all ofther coefs from Jensen et al. 2018
  twi_coef <- unname(model$coefficients[2])
  flow_coef <- unname(model$coefficients[3])

  b1x1 <- flow_coef * inputQ
  b2x2 <- twi_coef * input_logtwi

  #logistic regression from Jensen et al. 2018
  p <- exp(b0 + b1x1 + b2x2)/(1 + exp(b0 + b1x1 + b2x2))
  return(p)
}
#add just the 75 threshold
add_75 <- function(df){
  df$per_75 <- 0
  df$per_75[df$percent_flowing >= 75] <- 1

  return(df)
}
#calculate the accuracy from confusion matrix
accuracy_calc <- function(model, reference){
  mat <- confusionMatrix(factor(model, levels = c(0,1)), factor(reference, levels = c(0,1)))
  acc <- unname(mat$overall[1])
  return(acc)
}

#write a function to use in summarise
compare <- function(x, y, time){
  length(which(x == y))/length(time)*100
  }
```

```{r fb-stage-prepared}
#chunk that reads in stage, converts to proper units
#read in stage, convert to a height
FB_air <- read_csv("./PressureTransducers_11_14_23/FB_air.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_air = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

FB_water <- read_csv("./PressureTransducers_11_14_23/FB_water.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_water = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

data_23$mins <- minute(data_23$datetime)

#Fit a logistic regression to falls brook stage
#outputs df with stage in cm
FB_stage <- FB_water %>% 
  left_join(FB_air, by = "DATETIME") %>% 
  mutate(diff_psi = pressure_psi_water - pressure_psi_air) %>% 
  mutate(stage_cm = ((diff_psi*6894.76) / (997 * 9.8)) * 100 * 0.393701)


```

```{r fb-fitting-testing-topography-models}
FB_ready2split <-  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  #adding topographic metric of choice
  left_join(FB_twi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = '10mdem_twi') %>% 
  right_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))

set.seed(123)
#split data, 80% for training
train_full <- FB_ready2split %>% 
  slice_sample(prop = 0.8)
#20% for testing
test  <- anti_join(FB_ready2split, train_full, by = c("DATETIME", "ID"))
#prepare training dataset for model
train_values <- train_full %>% 
  select(binary, twi, stage_cm)
#fit the model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)

#calculating accuracy for the watershed (FB) and threshold (75) of interest
FB1 <- test %>% 
    mutate(percent_flowing = john_reg(log(twi), stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TWI",
              watershed = "FB")
FB1
```

TPI and drainage area for FB
```{r}
dem <-  "./fb_dems/10mdem.tif"
tpi_output <- "./fb_dems/10mdem_tpi.tif"

wbt_relative_topographic_position(
    dem = dem, 
    output = tpi_output, 
    filterx=11, 
    filtery=11
)
FB_tpi_ex <- extract(rast(tpi_output), lcc)

FB_uaa_ex <- extract(rast(flowacc_output), lcc)

#TPI#######
FB_ready2split <-  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  #adding topographic metric of choice
  left_join(FB_tpi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = '10mdem_tpi') %>% 
  right_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") 

set.seed(123)
#split data, 80% for training
train_full <- FB_ready2split %>% 
  slice_sample(prop = 0.8)
#20% for testing
test  <- anti_join(FB_ready2split, train_full, by = c("DATETIME", "ID"))
#prepare training dataset for model
train_values <- train_full %>% 
  select(binary, twi, stage_cm)
#fit the model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)

#calculating accuracy for the watershed (FB) and threshold (75) of interest
FB2 <- test %>% 
    mutate(percent_flowing = john_reg(twi, stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TWI",
              watershed = "FB")
FB2
######
#UAA
FB_ready2split <-  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  #adding topographic metric of choice
  left_join(FB_uaa_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = '10mdem_flowacc') %>% 
  right_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))

set.seed(123)
#split data, 80% for training
train_full <- FB_ready2split %>% 
  slice_sample(prop = 0.8)
#20% for testing
test  <- anti_join(FB_ready2split, train_full, by = c("DATETIME", "ID"))
#prepare training dataset for model
train_values <- train_full %>% 
  select(binary, twi, stage_cm)
#fit the model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)

#calculating accuracy for the watershed (FB) and threshold (75) of interest
FB3 <- test %>% 
    mutate(percent_flowing = john_reg(twi, stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TWI",
              watershed = "FB")
FB3

```

###zig zag
```{r zz-topography-prep}

#now do the same thing, but for zig zag
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "ZZ") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

slope_output <- "./fb_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
plot(twi2)

#just extract values from 10 m twi raster
dem <-  "./fb_dems/10mdem.tif"
tpi_output <- "./fb_dems/10mdem_tpi.tif"

wbt_relative_topographic_position(
    dem = dem, 
    output = tpi_output, 
    filterx=11, 
    filtery=11
)
#3 potential datasets to use to fit a regression
ZZ_tpi_ex <- extract(rast(tpi_output), lcc)
ZZ_uaa_ex <- extract(rast(flowacc_output), lcc)
ZZ_twi_ex <- extract(twi2, lcc)
```

```{r zz-stage-prep}
ZZ_air <- read_csv("./PressureTransducers_11_14_23/ZZ_air.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_air = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

ZZ_water <- read_csv("./PressureTransducers_11_14_23/ZZ_water.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_water = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

data_23$mins <- minute(data_23$datetime)

#Fit a logistic regression to falls brook stage
#outputs df with stage in cm
ZZ_stage <- ZZ_water %>% 
  left_join(ZZ_air, by = "DATETIME") %>% 
  mutate(diff_psi = pressure_psi_water - pressure_psi_air) %>% 
  mutate(stage_cm = ((diff_psi*6894.76) / (997 * 9.8)) * 100 * 0.393701)
```

```{r zz-model-fitting}
#Drainage area
##########
ready2split <-  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(ZZ_uaa_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "UAA" = `10mdem_flowacc`) %>% 
  right_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  mutate(UAA = log(UAA))

train_full <- ready2split %>% 
  slice_sample(prop = 0.8, replace = FALSE)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, UAA, stage_cm)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)



tested <- ready2split %>% 
    mutate(percent_flowing = john_reg(UAA, stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
  filter(mins %in% c(0, 30))



pt1 <- tested %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- tested %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

#calculating accuracy for the watershed (FB) and threshold (75) of interest
ZZ2 <- rbind(pt1, pt2) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "UAA",
              watershed = "ZZ")
ZZ2
#Topographic position
###########
ready2split <-  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(ZZ_tpi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "TPI" = `10mdem_tpi`) %>% 
  right_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME")

train_full <- ready2split %>% 
  slice_sample(prop = 0.8, replace = FALSE)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, TPI, stage_cm)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)



tested <- ready2split %>% 
    mutate(percent_flowing = john_reg(TPI, stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
  filter(mins %in% c(0, 30))



pt1 <- tested %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- tested %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

#calculating accuracy for the watershed (FB) and threshold (75) of interest
ZZ2 <- rbind(pt1, pt2) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TPI",
              watershed = "ZZ")
ZZ2
```

###W3
```{r w3-topography-prep}
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "W3") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

slope_output <- "./fb_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
#plot(twi2)

#just extract values from 10 m twi raster
#just extract values from 10 m twi raster
dem <-  "./fb_dems/10mdem.tif"
tpi_output <- "./fb_dems/10mdem_tpi.tif"

wbt_relative_topographic_position(
    dem = dem, 
    output = tpi_output, 
    filterx=11, 
    filtery=11
)
#3 potential datasets to use to fit a regression
W3_tpi_ex <- extract(rast(tpi_output), lcc)
W3_uaa_ex <- extract(rast(flowacc_output), lcc)
W3_twi_ex <- extract(twi2, lcc)
```

```{r w3-model-runs}
#twi
#######
data_23$binary <- 1
data_23$binary[data_23$wetdry == "dry"] <- 0
ready2split <-  
  data_23 %>% 
  mutate(mins = minute(datetime)) %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(w3_twi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = `10mdem_twi`) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))

set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, twi, Q_mm_day)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


#calculating accuracy for the watershed (FB) and threshold (75) of interest
ready2split %>% 
    mutate(percent_flowing = john_reg((twi), Q_mm_day) * 100) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TWI",
              watershed = "W3")
#tpi
#######
data_23$binary <- 1
data_23$binary[data_23$wetdry == "dry"] <- 0
ready2split <-  
  data_23 %>% 
  mutate(mins = minute(datetime)) %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(W3_tpi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "tpi" = `10mdem_tpi`) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") 

set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, tpi, Q_mm_day)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


#calculating accuracy for the watershed (FB) and threshold (75) of interest
ready2split %>% 
    mutate(percent_flowing = john_reg(tpi, Q_mm_day) * 100) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "TPI",
              watershed = "W3")
#uaa
#######

ready2split <-  
  data_23 %>% 
  mutate(mins = minute(datetime)) %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(W3_uaa_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "uaa" = `10mdem_flowacc`) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  mutate(uaa = log(uaa))

set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, uaa, Q_mm_day)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


#calculating accuracy for the watershed (FB) and threshold (75) of interest
ready2split %>% 
    mutate(percent_flowing = john_reg(uaa, Q_mm_day) * 100) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "UAA",
              watershed = "W3")
```

```{r w3-model-fitting}

```


##statistics. 
```{r w3}
#plot persistency versus discharge
#first calculate local persistency (pk)
pks <- data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    group_by(ID) %>% 
    slice_sample(prop = 0.8) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  select(ID, pk) %>% 
  ungroup()
  
  
#keep just values needed to fit model
train_values <-  data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    slice_sample(prop = 0.01) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  select(binary, pk, Q_mm_day)

#fit model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


tested <- data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>%
  mutate(percent_flowing = john_reg(pk, Q_mm_day) * 100)

tested %>% 
  mutate(mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "80% Obs",
              watershed = "W3")

```

```{r fb}
#plot persistency versus discharge
#first calculate local persistency (pk)
pks <- data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    group_by(ID) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  select(ID, pk) %>% 
  ungroup()
  
#keep just values needed to fit model
train_values <-  
  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  slice_sample(prop = 0.01, replace = FALSE) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  select(binary, pk, stage_cm)
#fit model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)

tested <- 
  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  rename("DATETIME" = datetime) %>% 
  right_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  mutate(percent_flowing = john_reg(pk, stage_cm) * 100)

pt1 <- tested %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- tested %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

rbind(pt1, pt2) %>% 
  mutate(mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "80% Obs",
              watershed = "FB")

```

```{r zz}
#plot persistency versus discharge
#first calculate local persistency (pk)
pks <- data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    group_by(ID) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  select(ID, pk) %>% 
  ungroup()
  
#keep just values needed to fit model
train_values <-  
  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  slice_sample(prop = 0.01, replace = FALSE) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  select(binary, pk, stage_cm)
#fit model
model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)

tested <- 
  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  rename("DATETIME" = datetime) %>% 
  right_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  mutate(percent_flowing = john_reg(pk, stage_cm) * 100)


pt1 <- tested %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- tested %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

rbind(pt1, pt2) %>% 
  mutate(mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) %>% 
    add_75() %>% 
    summarise(mean_accuracy = mean(accuracy_calc(per_75, binary)),
              input = "80% Obs",
              watershed = "ZZ")

```



**Making final figures for poster**
*topography based*
```{r w3-topography-prep}
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "W3") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

slope_output <- "./fb_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
#plot(twi2)

#just extract values from 10 m twi raster
w3_twi_ex <- extract(twi2, lcc)

```

```{r w3-Q-topo}
data_23$binary <- 1
data_23$binary[data_23$wetdry == "dry"] <- 0
ready2split <-  
  data_23 %>% 
  mutate(mins = minute(datetime)) %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(w3_twi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = `10mdem_twi`) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))

set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, twi, Q_mm_day)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


w3_topo <- 
  ready2split %>% 
    mutate(percent_flowing = john_reg(log(twi), Q_mm_day) * 100) %>% 
  add_thresholds() %>% 
  group_by(DATETIME, Q_mm_day) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement") %>% 
  filter(threshold == "threshold_75") %>% 
  mutate(shed = "W3")
#filter(DATETIME > start & DATETIME < stop) %>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = Q_mm_day, color = percent_agreement), lwd = 1)+
  #facet_wrap(~threshold, ncol = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")))+
  labs(title = "W3 75% threshold, log(TWI)",
       x = "",
       y = "Discharge (mm/day)")
w3_topo
```

```{r zz-Q-topo}

#now do the same thing, but for zig zag
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "ZZ") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

slope_output <- "./fb_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
plot(twi2)

#just extract values from 10 m twi raster
twi_ex <- extract(twi2, lcc)
ZZ_air <- read_csv("./PressureTransducers_11_14_23/ZZ_air.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_air = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

ZZ_water <- read_csv("./PressureTransducers_11_14_23/ZZ_water.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_water = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

data_23$mins <- minute(data_23$datetime)

#Fit a logistic regression to falls brook stage
#outputs df with stage in cm
ZZ_stage <- ZZ_water %>% 
  left_join(ZZ_air, by = "DATETIME") %>% 
  mutate(diff_psi = pressure_psi_water - pressure_psi_air) %>% 
  mutate(stage_cm = ((diff_psi*6894.76) / (997 * 9.8)) * 100 * 0.393701)

ready2split <-  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(twi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = '10mdem_twi') %>% 
  right_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))
set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, twi, stage_cm)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)



tested <- ready2split %>% 
    mutate(percent_flowing = john_reg(log(twi), stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
  filter(mins %in% c(0, 30))


out_zz <- add_thresholds(tested) %>% 
  group_by(DATETIME, stage_cm) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement")



pt1 <- out_zz %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- out_zz %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

zz_topo <- rbind(pt1, pt2) %>% 
    filter(threshold == "threshold_75") %>% 
  mutate(shed = "ZZ")
ggplot()+
  geom_line(aes(x = DATETIME, y = stage_cm, color = percent_agreement), lwd = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")))+
  labs(title = "ZZ 75% threshold, log(TWI)",
       x = "",
       y = "Stage (cm)")

zz_topo
```

*statistics*
```{r w3-Q-stats}
#what if I try to apply the botter and durighetto techniques?
#calculate local persistency
data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  group_by(ID) %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  arrange(pk)
  # left_join(twi_ex, by = "ID") %>% 
  # rename("DATETIME" = datetime,
  #        "twi" = w3_dem_twi) %>% 
  # left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  # #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  # mutate(twi = log(twi))

#each node needs to have some amount of stream length associated with it, and that turns on when that node turns on, until the node associated stream length matches the actual
#instead of stream length, how about discharge or stage?
#can I figure out a chunk of the discharge or stage that is associated with each one of these?

#plot persistency versus discharge

pks <- data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    group_by(ID) %>% 
    slice_sample(prop = 0.8) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  select(ID, pk) %>% 
  ungroup()
  
#how to determine the amount of discharge that increases due to one sensor location turning on
train_values <-  data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    slice_sample(prop = 0.8) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  select(binary, pk, Q_mm_day)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


tested <- data_23 %>% 
  filter(wshed == "W3", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(q_23_f, c(DATETIME, Q_mm_day)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>%
  mutate(percent_flowing = john_reg(pk, Q_mm_day) * 100)


w3_stats <- add_thresholds(tested) %>% 
  group_by(DATETIME, Q_mm_day) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement") %>% 
  filter(threshold == "threshold_75") #%>% 
#filter(DATETIME > start & DATETIME < stop) %>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = Q_mm_day, color = percent_agreement), lwd = 1)+
  #facet_wrap(~threshold, ncol = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")))+
  labs(title = "W3 75% threshold, Pk",
       x = "",
       y = "Discharge (mm/day)")

```

```{r zz-Q-stats}
#now make the graph from above, but for zig zag
#assume that all of the files are read in from above

#plot persistency versus discharge
#first calculate local persistency (pk)
pks <- data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
    group_by(ID) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  summarise(pk = sum(binary)/length(binary)) %>% 
  select(ID, pk) %>% 
  ungroup()
  
#how to determine the amount of discharge that increases due to one sensor location turning on
train_values <-  
  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  slice_sample(prop = 0.8, replace = FALSE) %>% 
  rename("DATETIME" = datetime) %>% 
  left_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  select(binary, pk, stage_cm)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)


tested <- 
  data_23 %>% 
  filter(wshed == "ZZ", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  rename("DATETIME" = datetime) %>% 
  right_join(select(ZZ_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  left_join(pks, by = "ID") %>% 
  mutate(percent_flowing = john_reg(pk, stage_cm) * 100)


add_thresholds(tested) %>% 
  group_by(ID) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement")

tested %>% 
  add_thresholds() %>% 
 group_by(DATETIME, stage_cm) %>% 
    #group_by(ID, DATETIME) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement") %>% 
  filter(threshold == "threshold_75") %>%
  #filter(ID %in% seq(15,30,1)) %>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = stage_cm, color = percent_agreement), lwd = 1)+
  #facet_wrap(~ID)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")))+
  labs(title = "ZZ 75% threshold, Pk",
       x = "",
       y = "Stage (cm)")

hydro <-  add_thresholds(tested) %>% 
  group_by(DATETIME, stage_cm) %>% 
  summarise(threshold_90 = compare(binary, per_90, DATETIME),
            threshold_75 = compare(binary, per_75, DATETIME),
            threshold_50 = compare(binary, per_50, DATETIME)) %>% 
  pivot_longer(cols = starts_with("threshold"), 
               names_to = "threshold", 
               values_to = "percent_agreement")

pt1 <- hydro %>% 
filter(DATETIME > "2023-07-23 00:00:00" & DATETIME < "2023-9-20 00:00:00")
pt2 <- hydro %>% 
filter(DATETIME > "2023-09-23 00:00:00" & DATETIME < "2023-11-10 00:00:00")

zz_stats <- rbind(pt1, pt2) %>% 
    filter(threshold == "threshold_75") %>%
  mutate(mins = minute(DATETIME)) %>% 
    filter(mins %in% c(0, 30)) #%>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = stage_cm, color = percent_agreement), lwd = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")))+
  labs(title = "ZZ 75% threshold, Pk",
       x = "",
       y = "Stage (cm)")
```

##combine all figures into one
```{r}
w3_topo

all_w3 <- rbind(mutate(w3_topo, type = "Topography"), 
                mutate(w3_stats, type = "Hierarchical")) %>%
  mutate(type = factor(type, levels = c("Topography", "Hierarchical")))


all_zz <- rbind(mutate(zz_topo, type = "Topography"), 
                mutate(zz_stats, type = "Hierarchical"))%>%
  mutate(type = factor(type, levels = c("Topography", "Hierarchical")))

w3Q <- all_w3 %>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = Q_mm_day, color = percent_agreement), lwd = 1)+
  facet_wrap(~type, nrow = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")),
                        name = "Accuracy")+
  labs(title = "W3 75% threshold",
       x = "",
       y = "Discharge (mm/day)")#+ theme(legend.position="")

zzQ <- all_zz %>% 
ggplot()+
  geom_line(aes(x = DATETIME, y = stage_cm, color = percent_agreement), lwd = 1)+
    facet_wrap(~type, nrow = 1)+
  theme_classic()+
  scale_color_gradientn(colors = rev(wes_palette("Zissou1", 100, type = "continuous")),
                        name = "Accuracy")+
  labs(title = "ZZ 75% threshold",
       x = "",
       y = "Stage (cm)")

ggsave("w3wide.png", plot = w3Q, height = 4.5, width = 14, units = "in", scale = 0.75)

ggsave("zzwide.png", plot = zzQ, height = 4.5, width = 14, units = "in", scale = 0.75)

ggsave("w3.png", plot = w3_map, scale = 2, limitsize = FALSE, height = 11,
       width = 9, units = "in", bg = NULL,)
```

