---
title: "Figures4Poster"
format: html
editor_options: 
  chunk_output_type: console
---

```{r reading-in-STIC-obs}
#loading packages
library(pacman)
p_load(tidyverse, terra, tidyterra, whitebox, scales, wesanderson, caret, plotly,
       ggnewscale, sf, rgeoboundaries, elevatr, patchwork)

#reading in final format data for summer 23
data_23 <- read_csv("./DataForMary/HB_stic.csv")
#reading in final format data for summer 24
data_24 <- read_csv("./summer2024/STICS2024.csv")
```

**Making maps for poster**

```{r fallsBrook-map}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#define the rectangular area that will be shown on final map
ybounds <- c(4868850,4869650)
xbounds <- c(279350, 280450)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./fb_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
fb_crop <- "./fb_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
fb_net <- vect("./carrieZigZag/FB_network.shp")
plot(fb_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
fb_pour_coords <- data.frame("easting" = 280400,
                             "northing" = 4869120)
#convert to SpatVector object
fb_pour <- vect(fb_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
fb_pour_filename <- "./fb_dems/fb_pour.shp"
writeVector(fb_pour, fb_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
fb_crop <- "./fb_dems/1mdem_crop.tif"

fb_breached <- "./fb_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = fb_crop,
  output = fb_breached,
  dist = 1,
  fill = TRUE)

fb_filled <- "./fb_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = fb_breached,
  output = fb_filled
)
#calculate flow accumulation and direction
fb_flowacc <- "./fb_dems/1mdem_fb_flowacc.tif"
wbt_d8_flow_accumulation(input = fb_filled,
                         output = fb_flowacc)
plot(rast(fb_flowacc))
fb_d8pt <- "./fb_dems/1mdem_fb_d8pt.tif"
wbt_d8_pointer(dem = fb_filled,
               output = fb_d8pt)
plot(rast(fb_d8pt))


#delineate streams
fb_streams <- "./fb_dems/fb_streams.tif"
wbt_extract_streams(flow_accum = fb_flowacc,
                    output = fb_streams,
                    threshold = 8000)
plot(rast(fb_streams))
points(lcc)
#snap pour point to streams
fb_pour_snap <- "./fb_dems/fb_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = fb_pour_filename,
                            streams = fb_streams,
                            output = fb_pour_snap,
                            snap_dist = 10)
fb_pour_snap_read <- vect("./fb_dems/fb_pour_snap.shp")
plot(rast(fb_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(fb_pour_snap_read, pch = 1)

fb_shed <- "./fb_dems/fb_shed.tif"
wbt_watershed(d8_pntr = fb_d8pt,
              pour_pts = fb_pour_snap,
              output = fb_shed)

plot(rast(fb_shed))
#convert raster of watershed area to vector for final mapping
fb_outline <- as.polygons(rast(fb_shed), extent=FALSE)
plot(fb_outline)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)

#assign destination for hillshade calculation
hillshade_out <- "./fb_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = fb_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)

#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
fb_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = fb_outline, fill = NA, color = "black", alpha = 0.3) +
  geom_sf(data = fb_net, colour = "darkslategray3") +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19) +
  geom_sf(data = fb_pour, colour = "black", pch = 8) +
   scale_fill_hypso_c(palette = "dem_screen", limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))

fb_map
```

Recreate this, but for ZZ

```{r zigZag-map}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "ZZ") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)
#define the rectangular area that will be shown on final map
ybounds <- c(4866400,4867500)
xbounds <- c(277200, 277650)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./zz_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
zz_crop <- "./zz_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
zz_net <- vect("./carrieZigZag/zigzag_streams.shp")
plot(zz_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
 4867436.45

zz_pour_coords <- data.frame("easting" = 277280.45,
                             "northing" = 4867436.45)
#convert to SpatVector object
zz_pour <- vect(zz_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
zz_pour_filename <- "./zz_dems/zz_pour.shp"
writeVector(zz_pour, zz_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
zz_crop <- "./zz_dems/1mdem_crop.tif"

zz_breached <- "./zz_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = zz_crop,
  output = zz_breached,
  dist = 1,
  fill = TRUE)

zz_filled <- "./zz_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = zz_breached,
  output = zz_filled
)
#calculate flow accumulation and direction
zz_flowacc <- "./zz_dems/1mdem_zz_flowacc.tif"
wbt_d8_flow_accumulation(input = zz_filled,
                         output = zz_flowacc)
plot(rast(zz_flowacc))
zz_d8pt <- "./zz_dems/1mdem_zz_d8pt.tif"
wbt_d8_pointer(dem = zz_filled,
               output = zz_d8pt)
plot(rast(zz_d8pt))


#delineate streams
zz_streams <- "./zz_dems/zz_streams.tif"
wbt_extract_streams(flow_accum = zz_flowacc,
                    output = zz_streams,
                    threshold = 8000)
plot(rast(zz_streams))
points(lcc)
#snap pour point to streams
zz_pour_snap <- "./zz_dems/zz_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = zz_pour_filename,
                            streams = zz_streams,
                            output = zz_pour_snap,
                            snap_dist = 10)
zz_pour_snap_read <- vect("./zz_dems/zz_pour_snap.shp")
plot(rast(zz_streams), 
     xlim = c(280200, 280410),
     ylim = c(4869300, 4869000))
points(zz_pour_snap_read, pch = 1)

zz_shed <- "./zz_dems/zz_shed.tif"
wbt_watershed(d8_pntr = zz_d8pt,
              pour_pts = zz_pour_snap,
              output = zz_shed)

plot(rast(zz_shed))
#convert raster of watershed area to vector for final mapping
zz_outline <- as.polygons(rast(zz_shed), extent=FALSE)
plot(zz_outline)



#assign destination for hillshade calculation
hillshade_out <- "./zz_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = zz_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)
#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
zz_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = zz_outline, fill = NA, color = "black", alpha = 0.3) +
  geom_sf(data = zz_net, colour = "darkslategray3") +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19) +
  geom_sf(data = zz_pour, colour = "black", pch = 8) +
   scale_fill_hypso_c(palette = "dem_screen", limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))

zz_map
```

Now do the same for W3!

```{r w3-map}
#read in DEM of whole valley, 1m resolution
dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
plot(m1)

#get sensor locations from STIC data, format
locs <- data_23 %>% 
  filter(wshed == "W3") %>% 
  select(ID, lat, long) %>% 
  unique()
#convert STIC data to a SpatVector data format
locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")
plot(locs_shape)
#reproject coordinates from WGS84 to NAD83 19N, which is the projection of raster
lcc <- terra::project(locs_shape, crs(m1))
plot(lcc)
#define the rectangular area that will be shown on final map
ybounds <- c(4870350,4871350)
xbounds <- c(281350, 282150)
plot(m1, xlim = xbounds, ylim = ybounds)
points(lcc)

#create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
crop1 <- crop(m1, ext(c(xbounds, ybounds)))
plot(crop1)
#save cropped 1m dem to reduce processing time below, and gurantee that everything has the same extent
writeRaster(crop1, "./w3_dems/1mdem_crop.tif", overwrite = TRUE)
#read in cropped dem
w3_crop <- "./w3_dems/1mdem_crop.tif"

#read in shapefile of stream network shape from ARC file on windows computer
w3_net <- vect("./carrieZigZag/w3_network.shp")
plot(w3_net)

###pour point to define where the watershed boundary is
#manually type coords from windows computer
 
 
w3_pour_coords <- data.frame("easting" = 281537.46,
                             "northing" = 4870424.50)
#convert to SpatVector object
w3_pour <- vect(w3_pour_coords,
                geom = c("easting", "northing"),
                   crs = crs(m1))
#snap pour point to make sure it lies on flowlines
#fb_pour <- snap(fb_pour, fb_net, tol = 1)

#save to file for use in whitebox functions
w3_pour_filename <- "./w3_dems/w3_pour.shp"
writeVector(w3_pour, w3_pour_filename, overwrite=TRUE)

####delineate watershed and keep watershed boundary
#breach and fill I guess
w3_crop <- "./w3_dems/1mdem_crop.tif"

w3_breached <- "./w3_dems/1mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = w3_crop,
  output = w3_breached,
  dist = 1,
  fill = TRUE)

w3_filled <- "./w3_dems/1mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = w3_breached,
  output = w3_filled
)
#calculate flow accumulation and direction
w3_flowacc <- "./w3_dems/1mdem_w3_flowacc.tif"
wbt_d8_flow_accumulation(input = w3_filled,
                         output = w3_flowacc)
plot(rast(w3_flowacc))
w3_d8pt <- "./w3_dems/1mdem_w3_d8pt.tif"
wbt_d8_pointer(dem = w3_filled,
               output = w3_d8pt)
plot(rast(w3_d8pt))


#delineate streams
w3_streams <- "./w3_dems/w3_streams.tif"
wbt_extract_streams(flow_accum = w3_flowacc,
                    output = w3_streams,
                    threshold = 8000)
plot(rast(w3_streams))
points(lcc)
#snap pour point to streams
w3_pour_snap <- "./w3_dems/w3_pour_snap.shp"
wbt_jenson_snap_pour_points(pour_pts = w3_pour_filename,
                            streams = w3_streams,
                            output = w3_pour_snap,
                            snap_dist = 10)
w3_pour_snap_read <- vect("./w3_dems/w3_pour_snap.shp")
plot(rast(w3_streams), 
     xlim = c(281400, 282000),
     ylim = c(4870400, 4870800))
points(w3_pour_snap_read, pch = 1)

w3_shed <- "./w3_dems/w3_shed.tif"
wbt_watershed(d8_pntr = w3_d8pt,
              pour_pts = w3_pour_snap,
              output = w3_shed)

plot(rast(w3_shed))
#convert raster of watershed area to vector for final mapping
w3_outline <- as.polygons(rast(w3_shed), extent=FALSE)
plot(w3_outline)



#assign destination for hillshade calculation
hillshade_out <- "./w3_dems/1mdem_hillshade.tif"
wbt_hillshade(
  dem = w3_crop,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
plot(hill)

#final plot with cropped hillshade and dem, STIC locations, watershed boundary, and stream network.
w3_map <- ggplot()+
  geom_spatraster(data = hill)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"))+
    new_scale_fill() +
  geom_spatraster(data = crop1, alpha = 0.5)+
    geom_sf(data = w3_outline, fill = NA, color = "black", alpha = 0.3)+
  geom_sf(data = w3_net, colour = "darkslategray3") +
    geom_sf(data = lcc, colour = "midnightblue", pch = 19) +
  geom_sf(data = w3_pour, colour = "black", pch = 8) +
   scale_fill_hypso_c(palette = "dem_screen" , limits = c(200, 1000))+
  theme(rect = element_rect(fill = "transparent", color = NA))
w3_map

w3_map
```

Combine maps, save

```{r combine-maps}
#combine all maps
all_map <- w3_map + fb_map + zz_map +
  theme(rect = element_rect(fill = "transparent", color = NA))

all_map
#24 in by 16
ggsave("threesheds.png", plot = all_map, units = c("in"),
       width = 12, height = 8, limitsize = TRUE, scale = 2)
```

```{r NH-map-unfinised}
#make map of NH, pane to show where hubbard brook is
usa <- rgeoboundaries::geoboundaries("USA", "adm1")
NH <- usa[usa$shapeName == "New Hampshire",]
NH_outline <- vect(NH)
mdt <- get_elev_raster(locations = NH, z = 10, clip = "locations")
plot(mdt)
big <- rast(mdt) %>% 
  crop(NH_outline) %>% 
  mask(NH_outline)
writeRaster(big, "./w3_dems/NH.tif", overwrite = TRUE)

NH_path <- "./w3_dems/NH.tif"
hillshade_out <- "./w3_dems/NH_hillshade.tif"
wbt_hillshade(
  dem = NH_path,
  output = hillshade_out,
)
hill <- rast(hillshade_out)
hill2 <- crop(hill, NH_outline)
hill3 <- mask(hill2, NH_outline)
plot(hill)

#read in shapefil of watershed boundaries for HB
#path to file
HB_bounds <- "./HB/hbef_wsheds/hbef_wsheds.shp"
sheds <- vect(HB_bounds)
sheds <- terra::project(sheds, crs(hill))


#use bounds of sheds to crop NH dem
ybounds <- c(43.916,43.96219)
xbounds <- c(-71.80451, -71.69687)
plot(hill, xlim = xbounds, ylim = ybounds)

ggplot()+
  geom_spatraster(data = hill3)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"), na.value = NA)+
    new_scale_fill() +
  geom_spatraster(data = big, alpha = 0.5)+
    geom_sf(data = sheds, fill = "darkslategray3", color = "black", alpha = 0.3) +
  # geom_sf(data = w3_net, colour = "darkslategray3") +
  #   geom_sf(data = lcc, colour = "midnightblue", pch = 19) +
  # geom_sf(data = w3_pour, colour = "black", pch = 8) +
   scale_fill_hypso_c(palette = "dem_screen")

ggplot()+
  geom_spatraster(data = hill3)+
  theme_void()+
  theme(legend.position = "")+
  scale_fill_gradientn(colors = c("black", "gray9", "gray48","lightgray", "white"), na.value = NA)+
    new_scale_fill() +
  geom_spatraster(data = big, alpha = 0.5)+
    geom_sf(data = sheds, fill = "darkslategray3", color = "black", alpha = 0.3) +
   scale_fill_hypso_c(palette = "dem_screen")+
  lims(x = xbounds,
       y = ybounds)
```

***Making tables for poster***  
*topography*  
Skipping just to fitting a model to stage

```{r fb-topography-prep}
#plot locations of sensors
locs <- data_23 %>% 
  filter(wshed == "FB") %>% 
  select(ID, lat, long) %>% 
  unique()

locs_shape <- vect(locs, 
                   geom=c("long", "lat"), 
                   crs = "+proj=longlat +datum=WGS84")



dem <- "./HB/1m hydro enforced DEM/dem1m.tif"
m1 <- rast(dem)
m10 <- aggregate(m1, 10)
#plot(m10)
lcc <- terra::project(locs_shape,crs(m10))

#save raster, because whitebox wants it is a files location instead of an object in R
writeRaster(m10, "./fb_dems/10mdem.tif", overwrite = TRUE)


breach_output <- "./fb_dems/10mdem_breach.tif"
wbt_breach_depressions_least_cost(
  dem = "./fb_dems/10mdem.tif",
  output = breach_output,
  dist = 10,
  fill = TRUE)

fill_output <- "./fb_dems/10mdem_fill.tif"
wbt_fill_depressions_wang_and_liu(
  dem = breach_output,
  output = fill_output
)

flowacc_output <- "./fb_dems/10mdem_flowacc.tif"
wbt_d_inf_flow_accumulation(input = fill_output,
                            output = flowacc_output,
                            out_type = "Specific Contributing Area")

slope_output <- "./fb_dems/10mdem_slope.tif"
wbt_slope(dem = fill_output,
          output = slope_output,
          units = "degrees")

twi_output <- "./fb_dems/10mdem_twi.tif"
wbt_wetness_index(sca = flowacc_output, #flow accumulation
                  slope = slope_output,
                  output = twi_output)

twi2 <- terra::rast(twi_output)
#plot(twi2)

#just extract values from 10 m twi raster
FB_twi_ex <- extract(twi2, lcc)

```

```{r fb-fitting-testing-topography-models}
#chunk that reads in stage, converts to proper units
#read in stage, convert to a height
FB_air <- read_csv("./PressureTransducers_11_14_23/FB_air.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_air = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

FB_water <- read_csv("./PressureTransducers_11_14_23/FB_water.csv", skip = 1) %>% 
  select(2:3) %>% 
  rename(DATETIME = 1,
         pressure_psi_water = 2) %>% 
  mutate(DATETIME = mdy_hms(DATETIME))

data_23$mins <- minute(data_23$datetime)

#Fit a logistic regression to falls brook stage
#outputs df with stage in cm
FB_stage <- FB_water %>% 
  left_join(FB_air, by = "DATETIME") %>% 
  mutate(diff_psi = pressure_psi_water - pressure_psi_air) %>% 
  mutate(stage_cm = ((diff_psi*6894.76) / (997 * 9.8)) * 100 * 0.393701)

ready2split <-  data_23 %>% 
  filter(wshed == "FB", mins %in% c(0, 30)) %>% 
  select(datetime, ID, lat, long, binary) %>% 
  left_join(FB_twi_ex, by = "ID") %>% 
  rename("DATETIME" = datetime,
         "twi" = '10mdem_twi') %>% 
  right_join(select(FB_stage, c(DATETIME, stage_cm)), by = "DATETIME") %>% 
  #select(DATETIME, ID, binary, twi, Q_mm_day) %>% 
  mutate(twi = log(twi))
set.seed(123)
train_full <- ready2split %>% 
  slice_sample(prop = 0.8)

#create test dataset
test  <- anti_join(ready2split, train_full, by = c("DATETIME", "ID"))

train_values <- train_full %>% 
  select(binary, twi, stage_cm)

model <- glm(binary ~.,family=binomial(link='logit'),data=train_values)
summary(model)

john_reg <- function(input_logtwi, inputQ){
  #b0, or intercept from Kevin's email from Carrie, might need to redo regression
  b0 <- unname(model$coefficients[1])
  #all ofther coefs from Jensen et al. 2018
  twi_coef <- unname(model$coefficients[2])
  flow_coef <- unname(model$coefficients[3])

  b1x1 <- flow_coef * inputQ
  b2x2 <- twi_coef * input_logtwi

  #logistic regression from Jensen et al. 2018
  p <- exp(b0 + b1x1 + b2x2)/(1 + exp(b0 + b1x1 + b2x2))
  return(p)
}

tested <- ready2split %>% 
    mutate(percent_flowing = john_reg(log(twi), stage_cm) * 100,
           mins = minute(DATETIME)) %>% 
  filter(mins %in% c(0, 30))

add_75 <- function(df){
  df$per_75 <- 0
  df$per_75[df$percent_flowing >= 75] <- 1

  return(df)
}

#add just the 75 threshold

#calculate the accuracy from confusion matrix
accuracy_calc <- function(model, reference){
  mat <- confusionMatrix(factor(model, levels = c(0,1)), factor(reference, levels = c(0,1)))
  acc <- unname(mat$overall[1])
  return(acc)
}

#calculating accuracy for the range of thresholds for each sensor
#ID_acc <- 
  add_75(tested) %>% 
    group_by(ID) %>% 
    summarise(test = accuracy_calc(per_75, binary))
```

**Making final figures for poster**
